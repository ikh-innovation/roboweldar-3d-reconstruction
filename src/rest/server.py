import ctypes
import logging
import os
import signal
import threading
import time

import pyfiware
from threading import Event
from flask import Flask

from config import ROOT_DIR
from src.log_parsing.scheduler import batch_parse_logs
from src.logging_config import ColorFormatter
from src.reconstruction.reconstruction import ThreeDReconstruction
from src.runner import SharedData, reconstruction, post_updates, log_parsing

# logging
formatter = ColorFormatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
handler = logging.StreamHandler()
handler.setFormatter(formatter)
logger = logging.getLogger("3d-reconstruction-service")
logger.addHandler(handler)
logger.setLevel(logging.INFO)

# Flask
app = Flask(__name__)


class StoppingThread(threading.Thread):

    def __init__(self, name, shared_data):
        """ constructor, setting initial variables """
        self._stop_event = threading.Event()
        self._sleep_period = 1.0
        self.shared_data = shared_data

        threading.Thread.__init__(self, name=name)

    def run(self):
        """ Example main control loop """
        count = 0
        while not self._stop_event.isSet():
            count += 1
            self._stop_event.wait(self._sleep_period)

    def join(self, timeout=None):
        """ Stop the thread. """
        self._stop_event.set()
        threading.Thread.join(self, timeout)


class ReconstructionThread(StoppingThread):
    def run(self):
        logger.debug("Starting Meshroom reconstruction thread...")

        # TODO: Provide links to images as arguments and download them to the "raw" dir prior to running further code

        threedreconstruction = ThreeDReconstruction(
            path_to_meshroom_root=os.path.join(ROOT_DIR, "deps", "Meshroom-2019.2.0"),
            path_to_images_dir=os.path.join(ROOT_DIR, "test", "box_reconstruction", "raw"),
            path_to_output_dir=os.path.join(ROOT_DIR, "test", "box_reconstruction", "output"),
            path_to_cache_dir=os.path.join(ROOT_DIR, "test", "box_reconstruction", "cache")
        )

        # If process returns exit code 0, it has completed successfully
        process = threedreconstruction.start()

        # Get stuck in this loop until stopevent flag is set
        while not self._stop_event.isSet() or process.returncode != 0:
            self._stop_event.wait(self._sleep_period)


        #######################################
        # Code for parsing STDOUT of process and logging it
        #
        # output = ""
        # for line in iter(process.stdout.readline, ""):
        #     logger.info(line)
        #     output += str(line)
        #
        # process.wait()
        # exit_code = process.returncode
        #
        # if exit_code == 0:
        #     return output
        # else:
        #     raise Exception(command, exit_code, output)
        #

        ######################################


        # If execution gets here before 3dreconstruction is finished, it kills the process
        logger.info("I got here!!!!!")
        # TODO: the process is not entirely killed and this becomes a blocking call for some reason, so thread does not terminate
        os.killpg(os.getpgid(process.pid), signal.SIGTERM)
        threedreconstruction.kill()

        logger.info("Exiting Meshroom reconstruction thread...")


class LogParserThread(StoppingThread):
    def run(self):
        # this thread will do the log parsing, and conversion into an appropriate data model
        logger.info("Starting Meshroom log parsing...")

        # while the stopflag is not set, keep parsing the logs generated by Meshroom
        while not self._stop_event.isSet():
            try:
                shared_data.logs = batch_parse_logs(path_to_cache_dir="/home/orfeas/Documents/Code/roboweldar/" \
                                                                      "roboweldar-3d-reconstruction/test/box_reconstruction/cache")
            except FileNotFoundError as err:
                logger.error(msg=err)
                continue
            except Exception as err:
                logger.error(msg=err)
                break

            self._stop_event.wait(self._sleep_period)

        logger.info("Exiting Meshroom log parsing...")


class UpdatesThread(StoppingThread):
    def run(self):

        logger.info("Starting update thread...")

        # while the stopflag is not set, keep posting updates to the Context Broker
        while not self._stop_event.isSet():
            try:
                if shared_data.logs:
                    for step in shared_data.logs:
                        logger.info("Sending mock POST request with data: {}".format(step))
                        # TODO: Need to create a REST service that sends updates to the Context Broker
            # except FileNotFoundError as err:
            #     logger.error(msg=err)
            #     continue
            except Exception as err:
                logger.error(msg=err)
                break

            self._stop_event.wait(self._sleep_period)

        logger.info("Stopping update thread...")


shared_data = SharedData(None)

reconstruction_thread = ReconstructionThread(name="reconstruction_thread", shared_data=shared_data)
# rest and log-parsing threads run infinitely and does not exit on its own, so it should be run in a daemonic thread
post_updates_thread = UpdatesThread(name="post_updates_thread", shared_data=shared_data)
logparser_thread = LogParserThread(name="log_parsing_thread", shared_data=shared_data)


@app.route("/start")
def start():
    # TODO:  JSON payload should contain downloadable links to images

    reconstruction_thread.start()
    logparser_thread.start()
    post_updates_thread.start()
    return "Started 3D reconstruction..."


@app.route("/stop")
def stop():
    post_updates_thread.join()

    logparser_thread.join()

    reconstruction_thread.join()
    return "Stopped 3D reconstruction..."


@app.route("/status")
def status():
    return "Stopped 3D reconstruction..."
